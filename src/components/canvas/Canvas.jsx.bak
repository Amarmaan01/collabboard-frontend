import { useRef, useEffect, useCallback, useState } from "react";

/* ═══════════════════════════════════════════════════════
   Utility — Shape Recognition
   ═══════════════════════════════════════════════════════ */
const recognizeShape = (points) => {
  if (points.length < 5) return null;
  const first = points[0];
  const last = points[points.length - 1];
  const dist = Math.hypot(last.x - first.x, last.y - first.y);

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  points.forEach((p) => {
    minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
    maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
  });
  const w = maxX - minX, h = maxY - minY;
  const diagonal = Math.hypot(w, h);

  let pathLen = 0;
  for (let i = 1; i < points.length; i++)
    pathLen += Math.hypot(points[i].x - points[i - 1].x, points[i].y - points[i - 1].y);

  const isClosed = dist < diagonal * 0.25;

  if (isClosed) {
    const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
    const avgR = (w + h) / 4;
    const ratio = pathLen / (2 * Math.PI * avgR);
    if (ratio > 0.75 && ratio < 1.5 && Math.abs(w - h) / Math.max(w, h) < 0.4)
      return { type: "circle", cx, cy, radius: avgR };

    let onEdge = 0;
    const margin = Math.max(w, h) * 0.15;
    points.forEach((p) => {
      if (Math.abs(p.x - minX) < margin || Math.abs(p.x - maxX) < margin ||
          Math.abs(p.y - minY) < margin || Math.abs(p.y - maxY) < margin) onEdge++;
    });
    if (onEdge / points.length > 0.7) return { type: "rect", x: minX, y: minY, width: w, height: h };
  }

  const lineLen = Math.hypot(last.x - first.x, last.y - first.y);
  if (lineLen > 30) {
    let maxDev = 0;
    points.forEach((p) => {
      const dev = Math.abs((last.y - first.y) * p.x - (last.x - first.x) * p.y + last.x * first.y - last.y * first.x) / lineLen;
      maxDev = Math.max(maxDev, dev);
    });
    if (maxDev < lineLen * 0.08) return { type: "line", x1: first.x, y1: first.y, x2: last.x, y2: last.y };
    if (maxDev < lineLen * 0.12) return { type: "arrow", x1: first.x, y1: first.y, x2: last.x, y2: last.y };
  }
  return null;
};

const drawRecognizedShape = (ctx, shape, color, brushSize) => {
  ctx.strokeStyle = color; ctx.lineWidth = brushSize; ctx.lineCap = "round"; ctx.lineJoin = "round";
  if (shape.type === "circle") { ctx.beginPath(); ctx.arc(shape.cx, shape.cy, shape.radius, 0, Math.PI * 2); ctx.stroke(); }
  else if (shape.type === "rect") { ctx.beginPath(); ctx.rect(shape.x, shape.y, shape.width, shape.height); ctx.stroke(); }
  else if (shape.type === "line") { ctx.beginPath(); ctx.moveTo(shape.x1, shape.y1); ctx.lineTo(shape.x2, shape.y2); ctx.stroke(); }
  else if (shape.type === "arrow") {
    ctx.beginPath(); ctx.moveTo(shape.x1, shape.y1); ctx.lineTo(shape.x2, shape.y2); ctx.stroke();
    const angle = Math.atan2(shape.y2 - shape.y1, shape.x2 - shape.x1);
    const hl = Math.max(12, brushSize * 4);
    ctx.beginPath(); ctx.moveTo(shape.x2, shape.y2);
    ctx.lineTo(shape.x2 - hl * Math.cos(angle - Math.PI / 6), shape.y2 - hl * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(shape.x2, shape.y2);
    ctx.lineTo(shape.x2 - hl * Math.cos(angle + Math.PI / 6), shape.y2 - hl * Math.sin(angle + Math.PI / 6));
    ctx.stroke();
  }
};

/* ═══════════════════════════════════════════════════════
   Utility — Lasso (point-in-polygon)
   ═══════════════════════════════════════════════════════ */
const pointInPolygon = (px, py, polygon) => {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const { x: xi, y: yi } = polygon[i];
    const { x: xj, y: yj } = polygon[j];
    if ((yi > py) !== (yj > py) && px < ((xj - xi) * (py - yi)) / (yj - yi) + xi) inside = !inside;
  }
  return inside;
};

const strokeInsideLasso = (stroke, lassoPoly) => {
  if (!stroke.points || stroke.points.length === 0) return false;
  return stroke.points.some((p) => pointInPolygon(p.x, p.y, lassoPoly));
};

/* ═══════════════════════════════════════════════════════
   Notebook Page Constants
   ═══════════════════════════════════════════════════════ */
const PAGE_WIDTH = 1200;
const PAGE_HEIGHT = Math.round(PAGE_WIDTH * 1.4142); // A4 ratio
const PAGE_GAP = 40;

/* ═══════════════════════════════════════════════════════
   Canvas Component
   ═══════════════════════════════════════════════════════ */
const Canvas = ({
  tool, color, brushSize,
  drawingLayer, textLayer, fileLayer,
  stickyNotes, laserPointers,
  onStrokeEnd, onDeleteStrokes, onMoveStrokes,
  socket, disabled,
  // Notebook pages
  pages, currentPage, onPageChange,
  // Zoom/pan (controlled from parent)
  zoom, panOffset, onZoomChange, onPanChange,
  // Lasso
  onLassoSelect,
}) => {
  const canvasRef = useRef(null);
  const ctxRef = useRef(null);
  const isDrawing = useRef(false);
  const currentStroke = useRef(null);
  const remoteStrokes = useRef(new Map());
  const lastThrottle = useRef(0);
  const loadedImages = useRef(new Map());
  const rafId = useRef(null);
  const redrawRef = useRef(null);

  // Lasso state
  const lassoPath = useRef(null);
  const [selectedIds, setSelectedIds] = useState([]);
  const [selectionBounds, setSelectionBounds] = useState(null);
  const isDraggingSelection = useRef(false);
  const dragStart = useRef({ x: 0, y: 0 });

  // HiDPI
  const dpr = typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;

  /* ─── Resize (HiDPI-aware) ─── */
  const resizeCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const parent = canvas.parentElement;
    if (!parent) return;
    const w = parent.clientWidth;
    const h = parent.clientHeight;
    if (w === 0 || h === 0) return;
    canvas.width = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    canvas.style.width = `${w}px`;
    canvas.style.height = `${h}px`;
    const ctx = canvas.getContext("2d");
    ctxRef.current = ctx;
    scheduleRedraw();
  }, [dpr]);

  useEffect(() => {
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
    return () => window.removeEventListener("resize", resizeCanvas);
  }, [resizeCanvas]);

  /* ─── Redraw scheduler (rAF batched) ─── */
  const scheduleRedraw = useCallback(() => {
    if (rafId.current) cancelAnimationFrame(rafId.current);
    rafId.current = requestAnimationFrame(() => {
      if (redrawRef.current) redrawRef.current();
    });
  }, []);

  useEffect(() => { scheduleRedraw(); }, [drawingLayer, textLayer, fileLayer, zoom, panOffset, pages, currentPage, selectedIds, laserPointers]);

  /* ─── Preload images ─── */
  useEffect(() => {
    if (!fileLayer || fileLayer.length === 0) return;
    fileLayer.forEach((img) => {
      if (!loadedImages.current.has(img.id)) {
        const image = new Image();
        image.crossOrigin = "anonymous";
        image.onload = () => { loadedImages.current.set(img.id, image); scheduleRedraw(); };
        image.src = img.src;
      }
    });
  }, [fileLayer]);

  /* ─── Remote strokes listener ─── */
  useEffect(() => {
    if (!socket) return;
    const handleRemoteStart = (data) => { remoteStrokes.current.set(data.userId, { ...data, points: data.points || [] }); };
    const handleRemoteMove = (data) => {
      const existing = remoteStrokes.current.get(data.userId);
      if (existing && data.point) { existing.points.push(data.point); scheduleRedraw(); }
    };
    socket.on("drawing:start", handleRemoteStart);
    socket.on("drawing:move", handleRemoteMove);
    return () => { socket.off("drawing:start", handleRemoteStart); socket.off("drawing:move", handleRemoteMove); };
  }, [socket]);

  /* ═══════════════════════════════════════════════════
     Coordinate Transform (zoom + pan aware)
     ═══════════════════════════════════════════════════ */
  const screenToCanvas = useCallback((clientX, clientY) => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0 };
    const rect = canvas.getBoundingClientRect();
    // Get CSS-pixel position relative to canvas element
    const sx = clientX - rect.left;
    const sy = clientY - rect.top;
    // Apply inverse zoom + pan to get canvas-space coords
    const z = zoom || 1;
    const ox = panOffset?.x || 0;
    const oy = panOffset?.y || 0;
    return { x: (sx - ox) / z, y: (sy - oy) / z };
  }, [zoom, panOffset]);

  const getClientPos = (e) => {
    if (e.touches && e.touches.length > 0) {
      return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
    }
    return { clientX: e.clientX, clientY: e.clientY };
  };

  /* ═══════════════════════════════════════════════════
     Drawing — Smooth Bézier + Pressure Simulation
     ═══════════════════════════════════════════════════ */
  const drawSmoothStroke = (ctx, stroke, isHighlighter = false) => {
    if (!ctx || !stroke.points || stroke.points.length < 2) return;

    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    if (isHighlighter || stroke.type === "highlighter") {
      ctx.globalAlpha = 0.3;
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.brushSize * 3;
    } else if (stroke.type === "eraser") {
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.lineWidth = stroke.brushSize;
    } else {
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.brushSize;
    }

    const pts = stroke.points;

    // Pressure simulation: vary width by speed
    if (pts.length >= 3 && stroke.type !== "eraser") {
      // Draw with variable width segments
      for (let i = 1; i < pts.length; i++) {
        const prev = pts[i - 1];
        const curr = pts[i];
        const speed = Math.hypot(curr.x - prev.x, curr.y - prev.y);
        const pressureFactor = Math.max(0.4, Math.min(1.2, 1.0 - speed / 200));
        const baseWidth = isHighlighter || stroke.type === "highlighter" ? stroke.brushSize * 3 : stroke.brushSize;
        ctx.lineWidth = baseWidth * pressureFactor;

        ctx.beginPath();
        if (i === 1) {
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
        } else {
          const prevPrev = pts[i - 2];
          const cpX = prev.x;
          const cpY = prev.y;
          const endX = (prev.x + curr.x) / 2;
          const endY = (prev.y + curr.y) / 2;
          ctx.moveTo((prevPrev.x + prev.x) / 2, (prevPrev.y + prev.y) / 2);
          ctx.quadraticCurveTo(cpX, cpY, endX, endY);
        }
        ctx.stroke();
      }
    } else {
      // Fallback: simple quadratic Bézier
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) {
        const midX = (pts[i - 1].x + pts[i].x) / 2;
        const midY = (pts[i - 1].y + pts[i].y) / 2;
        ctx.quadraticCurveTo(pts[i - 1].x, pts[i - 1].y, midX, midY);
      }
      ctx.stroke();
    }

    ctx.restore();
  };

  /* ─── Stroke render dispatcher ─── */
  const drawStroke = (ctx, stroke) => {
    if (!ctx) return;
    if (stroke.type === "recognized-shape" && stroke.recognizedShape) {
      drawRecognizedShape(ctx, stroke.recognizedShape, stroke.color, stroke.brushSize);
      return;
    }
    drawSmoothStroke(ctx, stroke);
  };

  /* ─── AI / text elements ─── */
  const drawAIElement = (ctx, el) => {
    if (!ctx) return;
    if (el.type === "box") {
      ctx.strokeStyle = "#6366f1"; ctx.lineWidth = 2;
      ctx.fillStyle = "rgba(99, 102, 241, 0.08)";
      ctx.beginPath(); ctx.roundRect(el.x, el.y, el.width || 150, el.height || 60, 8);
      ctx.fill(); ctx.stroke();
      if (el.text) {
        ctx.fillStyle = "#e8e8ed"; ctx.font = "14px Inter, sans-serif";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(el.text, el.x + (el.width || 150) / 2, el.y + (el.height || 60) / 2);
      }
    } else if (el.type === "arrow") {
      const fromBox = textLayer.find((t) => t.id === el.from);
      const toBox = textLayer.find((t) => t.id === el.to);
      if (fromBox && toBox) {
        const fx = fromBox.x + (fromBox.width || 150) / 2, fy = fromBox.y + (fromBox.height || 60);
        const tx = toBox.x + (toBox.width || 150) / 2, ty = toBox.y;
        ctx.strokeStyle = "#818cf8"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(fx, fy); ctx.lineTo(tx, ty); ctx.stroke();
        const angle = Math.atan2(ty - fy, tx - fx);
        ctx.beginPath(); ctx.moveTo(tx, ty);
        ctx.lineTo(tx - 10 * Math.cos(angle - Math.PI / 6), ty - 10 * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(tx - 10 * Math.cos(angle + Math.PI / 6), ty - 10 * Math.sin(angle + Math.PI / 6));
        ctx.closePath(); ctx.fillStyle = "#818cf8"; ctx.fill();
      }
    }
  };

  const drawImage = (ctx, img) => {
    const loaded = loadedImages.current.get(img.id);
    if (!loaded) return;
    const w = img.width || 200, h = img.height || 200;
    ctx.drawImage(loaded, img.x, img.y, w, h);
    ctx.strokeStyle = "rgba(99, 102, 241, 0.3)"; ctx.lineWidth = 1;
    ctx.strokeRect(img.x, img.y, w, h);
  };

  /* ═══════════════════════════════════════════════════
     Master Redraw
     ═══════════════════════════════════════════════════ */
  const redraw = () => {
    const ctx = ctxRef.current;
    const canvas = canvasRef.current;
    if (!ctx || !canvas) return;

    const z = zoom || 1;
    const ox = panOffset?.x || 0;
    const oy = panOffset?.y || 0;

    // Reset to identity and clear the entire pixel buffer
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Set up DPR scaling so we draw in CSS-pixel coordinates
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Apply zoom + pan on top of DPR
    ctx.save();
    ctx.translate(ox, oy);
    ctx.scale(z, z);

    // ─── Notebook page backgrounds ───
    const numPages = pages || 1;
    for (let p = 0; p < numPages; p++) {
      const yOff = p * (PAGE_HEIGHT + PAGE_GAP);
      // Page shadow
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(4, yOff + 4, PAGE_WIDTH, PAGE_HEIGHT);
      // Page bg
      ctx.fillStyle = "#181c2a";
      ctx.fillRect(0, yOff, PAGE_WIDTH, PAGE_HEIGHT);
      // Page border
      ctx.strokeStyle = "rgba(99,102,241,0.12)";
      ctx.lineWidth = 1;
      ctx.strokeRect(0, yOff, PAGE_WIDTH, PAGE_HEIGHT);
      // Subtle ruled lines
      ctx.strokeStyle = "rgba(99,102,241,0.04)";
      ctx.lineWidth = 0.5;
      for (let lY = yOff + 40; lY < yOff + PAGE_HEIGHT; lY += 40) {
        ctx.beginPath(); ctx.moveTo(20, lY); ctx.lineTo(PAGE_WIDTH - 20, lY); ctx.stroke();
      }
      // Page number
      ctx.fillStyle = "rgba(148,163,184,0.3)";
      ctx.font = "12px Inter, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(`Page ${p + 1}`, PAGE_WIDTH / 2, yOff + PAGE_HEIGHT - 12);
    }

    // ─── File layer (images) ───
    if (fileLayer) fileLayer.forEach((img) => drawImage(ctx, img));

    // ─── Drawing layer ───
    drawingLayer.forEach((stroke) => {
      // Highlight selected strokes
      if (selectedIds.includes(stroke.id)) {
        ctx.save();
        ctx.shadowColor = "#6366f1";
        ctx.shadowBlur = 8;
        drawStroke(ctx, stroke);
        ctx.restore();
      } else {
        drawStroke(ctx, stroke);
      }
    });

    // ─── Remote in-progress strokes ───
    remoteStrokes.current.forEach((stroke) => drawStroke(ctx, stroke));

    // ─── Current stroke ───
    if (currentStroke.current) drawStroke(ctx, currentStroke.current);

    // ─── AI / text elements ───
    textLayer.forEach((el) => drawAIElement(ctx, el));

    // ─── Selection bounds ───
    if (selectionBounds) {
      ctx.setLineDash([6, 4]);
      ctx.strokeStyle = "#6366f1";
      ctx.lineWidth = 1.5;
      ctx.strokeRect(selectionBounds.x - 4, selectionBounds.y - 4, selectionBounds.w + 8, selectionBounds.h + 8);
      ctx.setLineDash([]);
    }

    // ─── Lasso path in progress ───
    if (lassoPath.current && lassoPath.current.length > 1) {
      ctx.setLineDash([4, 4]);
      ctx.strokeStyle = "#a78bfa";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(lassoPath.current[0].x, lassoPath.current[0].y);
      for (let i = 1; i < lassoPath.current.length; i++) ctx.lineTo(lassoPath.current[i].x, lassoPath.current[i].y);
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);
    }

    ctx.restore(); // end zoom+pan

    // ─── Laser pointers (screen space) ───
    if (laserPointers && Object.keys(laserPointers).length > 0) {
      Object.values(laserPointers).forEach((lp) => {
        if (!lp.points || lp.points.length === 0) return;
        for (let i = Math.max(0, lp.points.length - 20); i < lp.points.length; i++) {
          const alpha = (i - Math.max(0, lp.points.length - 20)) / 20;
          // Transform point to screen
          const sx = lp.points[i].x * z + ox;
          const sy = lp.points[i].y * z + oy;
          ctx.beginPath(); ctx.arc(sx, sy, 4 + alpha * 4, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(239, 68, 68, ${alpha * 0.8})`; ctx.fill();
        }
        const last = lp.points[lp.points.length - 1];
        const lsx = last.x * z + ox, lsy = last.y * z + oy;
        ctx.beginPath(); ctx.arc(lsx, lsy, 8, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(239, 68, 68, 0.9)"; ctx.fill();
        ctx.beginPath(); ctx.arc(lsx, lsy, 12, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(239, 68, 68, 0.3)"; ctx.fill();
        if (lp.username) {
          ctx.font = "11px Inter, sans-serif"; ctx.fillStyle = "rgba(239, 68, 68, 0.9)";
          ctx.textAlign = "left"; ctx.fillText(lp.username, lsx + 14, lsy + 4);
        }
      });
    }
  };

  // Always keep redrawRef pointing to the latest redraw closure
  redrawRef.current = redraw;

  /* ═══════════════════════════════════════════════════
     Pointer Events
     ═══════════════════════════════════════════════════ */
  const handlePointerDown = (e) => {
    if (disabled || !tool) return;
    e.preventDefault();
    const { clientX, clientY } = getClientPos(e);
    const pos = screenToCanvas(clientX, clientY);

    // ─── Pan mode (middle mouse or space+drag handled via tool) ───
    if (tool === "pan") {
      isDrawing.current = true;
      dragStart.current = { x: clientX - (panOffset?.x || 0), y: clientY - (panOffset?.y || 0) };
      return;
    }

    // ─── Laser ───
    if (tool === "laser") {
      isDrawing.current = true;
      if (socket) socket.emit("laser:move", { point: pos });
      return;
    }

    // ─── Lasso ───
    if (tool === "lasso") {
      // Check if clicking inside existing selection to drag it
      if (selectionBounds && selectedIds.length > 0) {
        if (pos.x >= selectionBounds.x - 4 && pos.x <= selectionBounds.x + selectionBounds.w + 4 &&
            pos.y >= selectionBounds.y - 4 && pos.y <= selectionBounds.y + selectionBounds.h + 4) {
          isDraggingSelection.current = true;
          dragStart.current = { x: pos.x, y: pos.y };
          isDrawing.current = true;
          return;
        }
      }
      // Start new lasso
      setSelectedIds([]);
      setSelectionBounds(null);
      lassoPath.current = [pos];
      isDrawing.current = true;
      return;
    }

    // ─── Drawing ───
    isDrawing.current = true;
    const strokeType = tool === "eraser" ? "eraser" : tool === "shape" ? "shape" : tool === "highlighter" ? "highlighter" : "pencil";
    const stroke = {
      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      type: strokeType,
      points: [pos],
      color: tool === "eraser" ? "#0f0f14" : color,
      brushSize: tool === "eraser" ? brushSize * 3 : brushSize,
      userId: "self",
      layer: "drawingLayer",
      timestamp: Date.now(),
      pageId: currentPage || 0,
    };
    currentStroke.current = stroke;

    if (socket) {
      socket.emit("drawing:start", {
        id: stroke.id, type: stroke.type, points: [pos],
        color: stroke.color, brushSize: stroke.brushSize, layer: "drawingLayer",
      });
    }
  };

  const handlePointerMove = (e) => {
    if (!isDrawing.current || disabled) return;
    e.preventDefault();
    const { clientX, clientY } = getClientPos(e);

    // ─── Pan ───
    if (tool === "pan") {
      const newOx = clientX - dragStart.current.x;
      const newOy = clientY - dragStart.current.y;
      if (onPanChange) onPanChange({ x: newOx, y: newOy });
      return;
    }

    const pos = screenToCanvas(clientX, clientY);

    // ─── Laser ───
    if (tool === "laser") {
      const now = Date.now();
      if (now - lastThrottle.current > 30) { lastThrottle.current = now; if (socket) socket.emit("laser:move", { point: pos }); }
      return;
    }

    // ─── Lasso ───
    if (tool === "lasso") {
      if (isDraggingSelection.current) {
        const dx = pos.x - dragStart.current.x;
        const dy = pos.y - dragStart.current.y;
        dragStart.current = { x: pos.x, y: pos.y };
        if (onMoveStrokes) onMoveStrokes(selectedIds, dx, dy);
        if (selectionBounds) setSelectionBounds((b) => b ? { ...b, x: b.x + dx, y: b.y + dy } : b);
        return;
      }
      if (lassoPath.current) { lassoPath.current.push(pos); scheduleRedraw(); }
      return;
    }

    // ─── Drawing ───
    if (!currentStroke.current) return;
    currentStroke.current.points.push(pos);

    const now = Date.now();
    if (now - lastThrottle.current > 24) {
      lastThrottle.current = now;
      if (socket) socket.emit("drawing:move", { id: currentStroke.current.id, point: pos });
    }
    scheduleRedraw();
  };

  const handlePointerUp = (e) => {
    if (!isDrawing.current || disabled) return;
    e.preventDefault();
    isDrawing.current = false;

    if (tool === "pan") return;

    if (tool === "laser") { if (socket) socket.emit("laser:stop"); return; }

    // ─── Lasso finalize ───
    if (tool === "lasso") {
      if (isDraggingSelection.current) { isDraggingSelection.current = false; return; }
      if (lassoPath.current && lassoPath.current.length > 3) {
        const polygon = lassoPath.current;
        const inside = drawingLayer.filter((s) => strokeInsideLasso(s, polygon)).map((s) => s.id);
        setSelectedIds(inside);
        if (inside.length > 0) {
          const selected = drawingLayer.filter((s) => inside.includes(s.id));
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          selected.forEach((s) => s.points?.forEach((p) => {
            minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
          }));
          setSelectionBounds({ x: minX, y: minY, w: maxX - minX, h: maxY - minY });
          if (onLassoSelect) onLassoSelect(inside);
        }
      }
      lassoPath.current = null;
      scheduleRedraw();
      return;
    }

    // ─── Drawing finalize ───
    if (!currentStroke.current) return;
    const finishedStroke = { ...currentStroke.current };
    currentStroke.current = null;

    if (finishedStroke.points.length > 1) {
      if (finishedStroke.type === "shape") {
        const shape = recognizeShape(finishedStroke.points);
        if (shape) { finishedStroke.recognizedShape = shape; finishedStroke.type = "recognized-shape"; }
      }
      onStrokeEnd(finishedStroke);
    }
    scheduleRedraw();
  };

  /* ═══════════════════════════════════════════════════
     Wheel → Zoom
     ═══════════════════════════════════════════════════ */
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const handleWheel = (e) => {
      e.preventDefault();
      const { clientX, clientY } = e;
      const rect = canvas.getBoundingClientRect();
      const mx = clientX - rect.left;
      const my = clientY - rect.top;

      // Pinch zoom (trackpad) or ctrl+wheel
      if (e.ctrlKey || Math.abs(e.deltaY) < 50) {
        const delta = -e.deltaY * 0.005;
        const z = zoom || 1;
        const newZoom = Math.min(5, Math.max(0.1, z + delta));
        const ox = panOffset?.x || 0;
        const oy = panOffset?.y || 0;
        // Zoom toward cursor
        const factor = newZoom / z;
        const newOx = mx - (mx - ox) * factor;
        const newOy = my - (my - oy) * factor;
        if (onZoomChange) onZoomChange(newZoom);
        if (onPanChange) onPanChange({ x: newOx, y: newOy });
      } else {
        // Regular scroll → pan
        const ox = panOffset?.x || 0;
        const oy = panOffset?.y || 0;
        if (onPanChange) onPanChange({ x: ox - e.deltaX, y: oy - e.deltaY });
      }
    };

    canvas.addEventListener("wheel", handleWheel, { passive: false });
    return () => canvas.removeEventListener("wheel", handleWheel);
  }, [zoom, panOffset, onZoomChange, onPanChange]);

  /* ─── Keyboard shortcuts for selection ─── */
  useEffect(() => {
    const handleKey = (e) => {
      if (selectedIds.length === 0) return;
      if (e.key === "Delete" || e.key === "Backspace") {
        if (onDeleteStrokes) onDeleteStrokes(selectedIds);
        setSelectedIds([]); setSelectionBounds(null);
      }
      if (e.key === "d" && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        // Duplicate selection
        const dupes = drawingLayer
          .filter((s) => selectedIds.includes(s.id))
          .map((s) => ({
            ...s,
            id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            points: s.points.map((p) => ({ x: p.x + 20, y: p.y + 20 })),
          }));
        dupes.forEach((d) => onStrokeEnd(d));
        setSelectedIds(dupes.map((d) => d.id));
      }
    };
    window.addEventListener("keydown", handleKey);
    return () => window.removeEventListener("keydown", handleKey);
  }, [selectedIds, drawingLayer, onDeleteStrokes, onStrokeEnd]);

  /* ─── Cursor ─── */
  const getCursorStyle = () => {
    if (disabled) return "default";
    if (tool === "laser") return "none";
    if (tool === "pan") return "grab";
    if (tool === "lasso") return "crosshair";
    return "crosshair";
  };

  return (
    <canvas
      ref={canvasRef}
      id="whiteboard-canvas"
      onMouseDown={handlePointerDown}
      onMouseMove={handlePointerMove}
      onMouseUp={handlePointerUp}
      onMouseLeave={handlePointerUp}
      onTouchStart={handlePointerDown}
      onTouchMove={handlePointerMove}
      onTouchEnd={handlePointerUp}
      style={{ cursor: getCursorStyle() }}
    />
  );
};

export default Canvas;
